package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

var (
	prefix = flag.String("prefix", "", "prefix every file with this string (useful for build tags)")
)

func main() {
	flag.Parse()
	if *prefix != "" {
		*prefix = *prefix + "\n"
	}
	filesOrDirs := flag.Args()
	if len(filesOrDirs) <= 0 {
		filesOrDirs = append(filesOrDirs, ".")
	}
	for _, fileorDir := range filesOrDirs {
		generate(fileorDir)
	}
}

func generate(in string) {
	in = filepath.Clean(in)
	if isDir(in) {
		files, err := ioutil.ReadDir(in)
		if err != nil {
			panic(fmt.Sprintf("Could not list %s directory files: %s", in, err))
		}
		for _, file := range files {
			generate(in + "/" + file.Name())
		}
		return
	}
	file2Go(in)
}

func file2Go(file string) {
	if strings.HasSuffix(file, ".go") {
		return
	}
	outFile := file + ".go"
	varName := "B" + strings.Replace(strings.Replace(filepath.Base(file), ".", "_", -1), " ", "_", -1)
	packageName := filepath.Base(filepath.Dir(file))
	if packageName == "." {
		packageName, _ = os.Getwd()
		packageName = filepath.Base(packageName)
	}

	fmt.Printf("\n%s => %s", file, outFile)

	// Reader
	in, err := os.Open(file)
	if err != nil {
		panic(fmt.Sprintf("Could not read %s file: %s", file, err))
	}
	defer in.Close()

	// Writer
	out, err := os.Create(outFile)
	if err != nil {
		panic(fmt.Sprintf("Could not write to %s file: %s", outFile, err))
	}
	defer out.Close()

	// Read into array of bytes
	bs, err := ioutil.ReadAll(in)
	if err != nil {
		panic(fmt.Sprintf("Could not read file: %s", err))
	}

	if _, err := fmt.Fprintf(out, `%s// File automatically generated by file2go. Manual edits might get overwritten.

package %s

var %s = []byte(%q)
	`, *prefix, packageName, varName, string(bs)); err != nil {
		panic(fmt.Sprintf("Could not write contents: %s", err))
	}
}

func isDir(file string) bool {
	fi, err := os.Stat(file)
	if err != nil {
		panic(fmt.Sprintf("Could not determine if %s is a directory: %s", file, err))
	}
	return fi.IsDir()
}
